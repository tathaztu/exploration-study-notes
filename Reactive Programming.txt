

â€¢   Process is Heavy-Weight | Unit of Resources
â€¢   Thread: A process has at least one thread | Unit of Execution
â€¢   Every Thread has its own Stack Memory - a place where it's data is stored
    during context switches

ğğ«ğ¨ğ›ğ¥ğğ¦ ğ’ğ­ğšğ­ğğ¦ğğ§ğ­
â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”

â€¢   CPU is very expensive ($$)
    Try to use CPU as much as you can!
â€¢   Microservices Architecture often entails several network calls.
    Network calls are slow > Threads remain idle
    Developers create multiple threads compensate and maximize CPU Utilization
â€¢   Threads are Expensive!
â€¢   Expensive = Heavy/Consumes Memory

ğŸ‘‰   There was a need to make Network Calls more efficient without wasting System
    resources

ğ™¸/ğ™¾ ğ™²ğšŠğš•ğš•ğšœ
â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾
IO (Inbound / Outbound) | Desc.                                     Complexity
Blocking + Sync         : Current thread is blocked             |   1 (least)
Async                   : Delegated to a different Thread       |   2
Non-Blocking            : Current thread will be notified       |   3
Non-Blocking + Async    : A different thread will be notified   |   4 (most)

ğŸ“Œ Reactive Programming model simplifies the Non-Blocking + Async communication

ğ™²ğš˜ğš–ğš–ğšğš—ğš’ğšŒğšŠğšğš’ğš˜ğš— ğ™¿ğšŠğšğšğšğš›ğš—ğšœ
â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾
Reactive Programming allows us 4 kinds of Communication Patterns

Request     |        Request        |   Streaming Request   |   Streaming
 â†“   â†‘      |         â†“    â‡¡        |          â‡£    â†‘       |     â‡£   â‡¡
Response    |   Streaming Response  |        Response       |   Streaming
                   (Stock Prices)         (Apple Watch)       (Online Gaming)

ğšğšğšŠğšŒğšğš’ğšŸğš ğš‚ğšğš›ğšğšŠğš– ğš‚ğš™ğšğšŒğš’ğšğš’ğšŒğšŠğšğš’ğš˜ğš—ğšœ
â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾

Why?
    â€¢ Immediate Updates
    â€¢ Streaming <â€”> Streaming
    â€¢ Server should notify client about update(s)

Reactive Streams:
ğŸ§    Standard for Asynchronous Stream Processing with Non-Blocking Back Pressure.

    Process streams of messages in a non-blocking and asynchronous manner while
    handling back-pressure

ğŸ’¡   Observer Design Pattern

URL: https://www.reactive-streams.org

ğŸ‘‰   Observe and React to the stream of Data

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   public interface Publisher<T> {                     â”‚
            â”Œâ”€â”€â”€â”€â”€â”€>â”‚       public void subscribe(Subscriber <? super T> s);â”‚
            â•       â”‚   }                                                   â”‚
            â•       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â•                                           É…
            â•                                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   public interface Subscription { â”‚                   â”‚
â”‚       public void request(long n);â”‚                   â”‚
â”‚       public void cancel();       â”‚                   â”‚
â”‚   }                               â”‚                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
            É…                                           â”‚
            â”‚                                           â”‚
            â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚               â”‚   public interface Subscriber<T> {            â”‚
            â”‚               â”‚       public void onSubscribe(Subscription s);â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚       public void onNext(T t);                â”‚
                            â”‚       public void onError(Throwable t);       â”‚
                            â”‚       public void onComplete();               â”‚
                            â”‚   }                                           â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


The processor class acts as both Publisher and Subscriber

public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}

We can have a hierarchy like, e.g.
    Publisher â•Œâ•Œâ•Œ Processor â•Œâ•Œâ•Œ Processor â•Œâ•Œâ•Œ Subscriber

ğ—¥ğ—²ğ—®ğ—°ğ˜ğ—¼ğ—¿ - https://projectreactor.io

Reactor is a fully non-blocking, reactive programming library for building
efficient and scalable applications on the JVM, based on the Reactive Streams
specification.
It provides composable APIs (Flux for 0-N items and Mono for 0-1 item) to manage
asynchronous data streams with backpressure support.

ğ™¿ğšğš‹ğš•ğš’ğšœğš‘ğšğš› ğš‚ğšğš‹ğšœğšŒğš›ğš’ğš‹ğšğš› ğ™²ğš˜ğš–ğš–ğšğš—ğš’ğšŒğšŠğšğš’ğš˜ğš—
â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾


            ğŸ”—   Publisher.subscribe(Subscriber)
            ---------------------------------------->
Subscriber                                              Publisher
            <----------------------------------------
                Subscriber.onSubscribe(ğ˜šğ˜¶ğ˜£ğ˜´ğ˜¤ğ˜³ğ˜ªğ˜±ğ˜µğ˜ªğ˜°ğ˜¯)

                    ğ˜šğ˜¶ğ˜£ğ˜´ğ˜¤ğ˜³ğ˜ªğ˜±ğ˜µğ˜ªğ˜°ğ˜¯.request(long n)
            ---------------------------------------->
Subscriber                  â—€â”€â”€â”€â”€â–¶                      Publisher
            <----------------------------------------
                    Subscriber.next(T) .. n-Times


ğŸ›‘   End of Association

                    Subscriber.onError(Throwable)
Subscriber  <----------------------------------------   Publisher

                    Subscriber.onComplete()
Subscriber  <----------------------------------------   Publisher

                    ğ˜šğ˜¶ğ˜£ğ˜´ğ˜¤ğ˜³ğ˜ªğ˜±ğ˜µğ˜ªğ˜°ğ˜¯.cancel()
Subscriber  ---------------------------------------->   Publisher


ğšƒğšğš›ğš–ğš’ğš—ğš˜ğš•ğš˜ğšğš’ğšğšœ
â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾
â€¢ Publisher
    Source  | Ovservable | Upstream   | Producer
â€¢ Subscriber
    Sink    | Observer   | Downstream | Consumer
â€¢ Processor
    Operator


ğšğšğš•ğšğšœ ğš˜ğš ğšğšğšŠğšŒğšğš’ğšŸğš ğ™¿ğš›ğš˜ğšğš›ğšŠğš–ğš–ğš’ğš—ğš
â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾

â€¢   Subscriber has to subscribe and request for the producer to produce items.
    The idea is to be lazy
â€¢   Subscriber can cancel anytime.
â€¢   If there are no Subscribers left, then the Producer will not produce anything
â€¢   Producer will produce items via. onNext
â€¢   Producer will call onComplete after emitting 0...N data.

    According to the ğ—¥ğ—²ğ—®ğ—°ğ˜ğ—¶ğ˜ƒğ—² ğ—¦ğ˜ğ—¿ğ—²ğ—®ğ—ºğ˜€ ğ—¦ğ—½ğ—²ğ—°ğ—¶ğ—³ğ—¶ğ—°ğ—®ğ˜ğ—¶ğ—¼ğ—», a ğ™¿ğšğš‹ğš•ğš’ğšœğš‘ğšğš› stream must
    call the ğš˜ğš—ğ™²ğš˜ğš–ğš™ğš•ğšğšğš() signal to its ğš‚ğšğš‹ğšœğšŒğš›ğš’ğš‹ğšğš› when it has successfully
    transmitted all the data and there are no more elements to emit.

    This signals the end of the stream and indicates that the Subscriber will
    not receive any further ğš˜ğš—ğ™½ğšğš¡ğš() calls from this Publisher.

    In Reactor, both ğ™µğš•ğšğš¡ (for streams of 0 .. N elements) and ğ™¼ğš˜ğš—ğš˜ (for
    streams of 0 or 1 element) will emit an ğš˜ğš—ğ™²ğš˜ğš–ğš™ğš•ğšğšğš() signal under normal
    completion scenarios after all data has been emitted.

â€¢ Producer will call onError when something breaks
â€¢ Producer will not invoke anything after onComplete/onError


  ____                 _
 |  _ \ ___  __ _  ___| |_ ___  _ __
 | |_) / _ \/ _` |/ __| __/ _ \| '__|
 |  _ <  __/ (_| | (__| || (_) | |
 |_| \_\___|\__,_|\___|\__\___/|_|


    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   public interface Publisher<T> {                     â”‚
    â”‚       public void subscribe(Subscriber <? super T> s);â”‚ ğ—£ğ˜‚ğ—¯ğ—¹ğ—¶ğ˜€ğ—µğ—²ğ—¿
    â”‚   }                                                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                â”‚                           â”‚
                â”‚                           â”‚
                â”‚                           â”‚
                Ë…                           Ë…
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            â”‚  Mono<T>  â”‚               â”‚  Flux<T>  â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯               â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
            â€¢ O or 1 item               â€¢ 0 .. N items
            â€¢ onComplete / onError      â€¢ onComplete / onError
            â€¢ No Stream                 â€¢ Stream of messages
            â€¢ No Back-Pressure          â€¢ Back-Pressure (produce more than
            â€¢ Light-Weight Publisher      what can be consumed)
            â€¢ Request-Response model    â€¢ Many additional methods related to
                                          stream processing


    Both Mono and Flux can handle records in a Non-Blocking and Asynchronous
    manner

    ğ—¥ğ—²ğ—®ğ—°ğ˜ğ—¶ğ˜ƒğ—² ğ—¦ğ˜ğ—¿ğ—²ğ—®ğ—ºğ˜€ ğ—®ğ—¿ğ—² ğ—¶ğ—»ğ—µğ—²ğ—¿ğ—²ğ—»ğ˜ğ—¹ğ˜† ğ—Ÿğ—®ğ˜‡ğ˜†. Â 

    Operations within a Reactive Streams Pipeline are not executed until a
    Subscriber actively subscribes to the Publisher and starts requesting data.
    The following reasons explain the behavior -

    ğ—¡ğ—¼ ğ—¦ğ˜‚ğ—¯ğ˜€ğ—°ğ—¿ğ—¶ğ—½ğ˜ğ—¶ğ—¼ğ—», ğ—¡ğ—¼ ğ—ªğ—¼ğ—¿ğ—¸: Until a Subscriber calls the subscribe() method on
    a Publisher, the Publisher does not start producing or processing any data.

    ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ ğ—™ğ˜‚ğ˜€ğ—¶ğ—¼ğ—»: Reactive Streams implementations (like Reactor and RxJava)
    often employ operator fusion techniques. This can optimize the execution by
    combining multiple operators into a single step, which only happens when the
    stream is actually consumed. Â 

    ğ——ğ—²ğ—ºğ—®ğ—»ğ—±-ğ——ğ—¿ğ—¶ğ˜ƒğ—²ğ—»: The Subscriber controls the rate at which it receives data
    by making explicit requests (using the request(n) method). The Publisher
    only produces and pushes data in response to this demand. This pull-based
    backpressure mechanism further reinforces the lazy nature.

    Reactive Streams set up a blueprint for data processing, but the actual
    processing is deferred until there's a consumer actively pulling the data
    through the pipeline. This lazy evaluation is crucial for efficiency,
    especially when dealing with potentially large or infinite streams of data.

    â•”â•â•â•â•â•â•â•â•—
    â•‘  Mono â•‘
    â•šâ•â•â•â•â•â•â•â•

    ğ— ğ—¼ğ—»ğ—¼<ğ—§> ğ—·ğ˜‚ğ˜€ğ˜(ğ—§ ğ—±ğ—®ğ˜ğ—®)

    â—‹   A common use case of this method would be to create a Mono type
    Publisher to match the parameter(s) of a method which requires a Publisher,
    in place of the "data".
    â—‹   Use 'just' when the values we need to send, need to be in the memory

    ğ— ğ—¼ğ—»ğ—¼.ğ˜€ğ˜‚ğ—¯ğ˜€ğ—°ğ—¿ğ—¶ğ—¯ğ—²(ğ—™ğ˜‚ğ—»ğ—°ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—œğ—»ğ˜ğ—²ğ—¿ğ—³ğ—®ğ—°ğ—²(ğ˜€))

    â—‹   The request method to the Subscription is automatically created by the
    Reactor runtime based on the method call.

    ğ— ğ—¼ğ—»ğ—¼.ğ—³ğ—¿ğ—¼ğ—ºğ—¦ğ˜‚ğ—½ğ—½ğ—¹ğ—¶ğ—²ğ—¿(ğ—¦ğ˜‚ğ—½ğ—½ğ—¹ğ—¶ğ—²ğ—¿<? ğ—²ğ˜…ğ˜ğ—²ğ—»ğ—±ğ˜€ ğ—§> ğ˜€ğ˜‚ğ—½ğ—½ğ—¹ğ—¶ğ—²ğ—¿)

    â—‹   Delay compute intensive operation
    â—‹   Supports any supplier

    ğ— ğ—¼ğ—»ğ—¼.ğ—³ğ—¿ğ—¼ğ—ºğ—–ğ—®ğ—¹ğ—¹ğ—®ğ—¯ğ—¹ğ—²(ğ—–ğ—®ğ—¹ğ—¹ğ—®ğ—¯ğ—¹ğ—²<? ğ—²ğ˜…ğ˜ğ—²ğ—»ğ—±ğ˜€ ğ—§> ğ˜€ğ˜‚ğ—½ğ—½ğ—¹ğ—¶ğ—²ğ—¿)

    â—‹   The callable interface is a very old interface and has existed
    â—‹   JavaDocs

        A task that returns a result and may throw an exception. Implementors
        define a single method with no arguments called call.

        The Callable interface is similar to Runnable, in that both are designed
        for classes whose instances are potentially executed by another thread.

        A Runnable, however, does not return a result and cannot throw a checked
        exception.

        Callable throws Exception whereas Supplier throws RuntimeException

    â—‹   Callable has a throws clause | Supplier doesn't

    ğ— ğ—¼ğ—»ğ—¼.ğ—³ğ—¿ğ—¼ğ—ºğ—¥ğ˜‚ğ—»ğ—»ğ—®ğ—¯ğ—¹ğ—²(ğ—¥ğ˜‚ğ—»ğ—»ğ—®ğ—¯ğ—¹ğ—² ğ—¿ğ˜‚ğ—»ğ—»ğ—®ğ—¯ğ—¹ğ—²)

    â—‹   Perform a task and return an Mono.Empty after the Runnable, that is
        passed as a parameter has been executed

    ğ— ğ—¼ğ—»ğ—¼.ğ—³ğ—¿ğ—¼ğ—ºğ—™ğ˜‚ğ˜ğ˜‚ğ—¿ğ—²(ğ—–ğ—¼ğ—ºğ—½ğ—¹ğ—²ğ˜ğ—®ğ—¯ğ—¹ğ—²ğ—™ğ˜‚ğ˜ğ˜‚ğ—¿ğ—²<? ğ—²ğ˜…ğ˜ğ—²ğ—»ğ—±ğ˜€ ğ—§> ğ—³ğ˜‚ğ˜ğ˜‚ğ—¿ğ—²)

    â—‹   Integrate existing asynchronous operations that are based on
        CompletableFuture into a Reactor-based reactive pipeline.

    â—‹   If the CompletableFuture completes successfully with a value, the Mono
        will emit that value as an onNext() signal followed by an onComplete()
        signal.

    â—‹   If the CompletableFuture completes without a value (i.e., a
        CompletableFuture<Void>), the Mono will simply emit an onComplete()
        signal.

    â—   CompletableFuture is not lazy. If Mono.fromFuture is associated with a
        CompletableFuture and there is no association with a subscriber, then
        that is not a Lazy computation because the computation of the
        CompletableFuture code will start immediately.

        Mono
            .fromFuture(getName());

        private static CompletableFuture<String> getName() {
            return CompletableFuture.supplyAsync(() -> {
                logger.info("Get Name from CompletableFuture");
                return Util.faker().name().firstName();
            });
        }

    â—‹   CompletableFuture can be made to execute with a delay by using it in the
        form of a Supplier

        Mono
            .fromFuture(()-> getName());

    ğ— ğ—¼ğ—»ğ—¼.ğ—±ğ—²ğ—³ğ—²ğ—¿(ğ—¦ğ˜‚ğ—½ğ—½ğ—¹ğ—¶ğ—²ğ—¿<? ğ—²ğ˜…ğ˜ğ—²ğ—»ğ—±ğ˜€ ğ— ğ—¼ğ—»ğ—¼<? ğ—²ğ˜…ğ˜ğ—²ğ—»ğ—±ğ˜€ ğ—§>> ğ˜€ğ˜‚ğ—½ğ—½ğ—¹ğ—¶ğ—²ğ—¿)

    â—‹   Defer the invocation of the Publisher


    ğ—Ÿğ—¼ğ—¼ğ—½ğ—¥ğ—²ğ˜€ğ—¼ğ˜‚ğ—¿ğ—°ğ—²ğ˜€

    ğš›ğšğšŠğšŒğšğš˜ğš›.ğš—ğšğšğšğš¢.ğš›ğšğšœğš˜ğšğš›ğšŒğšğšœ.ğ™»ğš˜ğš˜ğš™ğšğšğšœğš˜ğšğš›ğšŒğšğšœ

    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
    â”‚ Non Blocking IO (Simplified)  â”‚
    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

    ğ—œğ—»ğ—¯ğ—¼ğ˜‚ğ—»ğ—±
                [6]     [5]     [4]                 â•­>â•®         [3]
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>         â†‘ â”‚     -------------->
    <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚ â†“     <--------------
                                                    â•°<â•¯         [1]
                ğ—¢ğ˜‚ğ˜ğ—¯ğ—¼ğ˜‚ğ—»ğ—±                        ğ—˜ğ˜ƒğ—²ğ—»ğ˜ ğ—Ÿğ—¼ğ—¼ğ—½
                                                   ğ˜›ğ˜©ğ˜³ğ˜¦ğ˜¢ğ˜¥
    â€¢ Send the first Request | Don't sit idle
    â€¢ Pick the next Request

    â•”â•â•â•â•â•â•â•â•—
    â•‘ Flux  â•‘
    â•šâ•â•â•â•â•â•â•â•

	â—‹	ğ—Ÿğ—¼ğ—´ ğ—¨ğ—»ğ—¯ğ—¼ğ˜‚ğ—»ğ—±ğ—²ğ—±: 
		Requesting for Integer.MAX_VALUE number of items cause the Log() method of Flux to print 'unbounded'
	â—‹	The log method can only print what is happening between its producer and
		its subscriber
	â—‹	ğ—™ğ—¹ğ˜‚ğ˜… ğ—³ğ—¿ğ—¼ğ—º ğ—¦ğ˜ğ—¿ğ—²ğ—®ğ—ºğ˜€
		When creating a Flux from Streams, we need to be aware that Streams are
		invalidated when they end
	â—‹	Flux Interval
		This carries on until explicitly told to stop
	â—‹	ğ—™ğ—¹ğ˜‚ğ˜….ğ—±ğ—²ğ—³ğ—²ğ—¿
		Delay Execution. Operates similar to Supplier, Callable & Runnable.
	â—‹	Mono <â€”> Flux




