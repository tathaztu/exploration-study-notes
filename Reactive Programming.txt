

â€¢   Process is Heavy-Weight | Unit of Resources
â€¢   Thread: A process has at least one thread | Unit of Execution
â€¢   Every Thread has its own Stack Memory - a place where it's data is stored
    during context switches

ğğ«ğ¨ğ›ğ¥ğğ¦ ğ’ğ­ğšğ­ğğ¦ğğ§ğ­
â–”â–”â–”â–”â–”â–”â–”â–”â–”â–”

â€¢   CPU is very expensive ($$)
    Try to use CPU as much as you can!
â€¢   Microservices Architecture often entails several network calls.
    Network calls are slow > Threads remain idle
    Developers create multiple threads compensate and maximize CPU Utilization
â€¢   Threads are Expensive!
â€¢   Expensive = Heavy/Consumes Memory

ğŸ‘‰ 	There was a need to make Network Calls more efficient without wasting 
	System resources

ğ™¸/ğ™¾ ğ™²ğšŠğš•ğš•ğšœ
â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾
IO (Inbound / Outbound) | Desc.                                     Complexity
Blocking + Sync         : Current thread is blocked             |   1 (least)
Async                   : Delegated to a different Thread       |   2
Non-Blocking            : Current thread will be notified       |   3
Non-Blocking + Async    : A different thread will be notified   |   4 (most)

ğŸ“Œ Reactive Programming model simplifies the Non-Blocking + Async communication

ğ™²ğš˜ğš–ğš–ğšğš—ğš’ğšŒğšŠğšğš’ğš˜ğš— ğ™¿ğšŠğšğšğšğš›ğš—ğšœ
â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾
Reactive Programming allows us 4 kinds of Communication Patterns

Request     |        Request        |   Streaming Request   |   Streaming
 â†“   â†‘      |         â†“    â‡¡        |          â‡£    â†‘       |     â‡£   â‡¡
Response    |   Streaming Response  |        Response       |   Streaming
                   (Stock Prices)         (Apple Watch)       (Online Gaming)

ğšğšğšŠğšŒğšğš’ğšŸğš ğš‚ğšğš›ğšğšŠğš– ğš‚ğš™ğšğšŒğš’ğšğš’ğšŒğšŠğšğš’ğš˜ğš—ğšœ
â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾

Why?
    â€¢ Immediate Updates
    â€¢ Streaming <â€”> Streaming
    â€¢ Server should notify client about update(s)

Reactive Streams:
ğŸ§  	Standard for Asynchronous Stream Processing with Non-Blocking Back Pressure.

    Process streams of messages in a non-blocking and asynchronous manner while
    handling back-pressure

ğŸ’¡   Observer Design Pattern

URL: https://www.reactive-streams.org

ğŸ‘‰   Observe and React to the stream of Data

                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   public interface Publisher<T> {                     â”‚
            â”Œâ”€â”€â”€â”€â”€â”€>â”‚       public void subscribe(Subscriber <? super T> s);â”‚
            â•       â”‚   }                                                   â”‚
            â•       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â•                                           É…
            â•                                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   public interface Subscription { â”‚                   â”‚
â”‚       public void request(long n);â”‚                   â”‚
â”‚       public void cancel();       â”‚                   â”‚
â”‚   }                               â”‚                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
            É…                                           â”‚
            â”‚                                           â”‚
            â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚               â”‚   public interface Subscriber<T> {            â”‚
            â”‚               â”‚       public void onSubscribe(Subscription s);â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚       public void onNext(T t);                â”‚
                            â”‚       public void onError(Throwable t);       â”‚
                            â”‚       public void onComplete();               â”‚
                            â”‚   }                                           â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


The processor class acts as both Publisher and Subscriber

public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}

We can have a hierarchy like, e.g.
    Publisher â•Œâ•Œâ•Œ Processor â•Œâ•Œâ•Œ Processor â•Œâ•Œâ•Œ Subscriber

ğ—¥ğ—²ğ—®ğ—°ğ˜ğ—¼ğ—¿ - https://projectreactor.io

Reactor is a fully non-blocking, reactive programming library for building
efficient and scalable applications on the JVM, based on the Reactive Streams
specification.
It provides composable APIs (Flux for 0-N items and Mono for 0-1 item) to manage
asynchronous data streams with backpressure support.

ğ™¿ğšğš‹ğš•ğš’ğšœğš‘ğšğš› ğš‚ğšğš‹ğšœğšŒğš›ğš’ğš‹ğšğš› ğ™²ğš˜ğš–ğš–ğšğš—ğš’ğšŒğšŠğšğš’ğš˜ğš—
â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾


            ğŸ”—   Publisher.subscribe(Subscriber)
            ---------------------------------------->
Subscriber                                              Publisher
            <----------------------------------------
                Subscriber.onSubscribe(ğ˜šğ˜¶ğ˜£ğ˜´ğ˜¤ğ˜³ğ˜ªğ˜±ğ˜µğ˜ªğ˜°ğ˜¯)

                    ğ˜šğ˜¶ğ˜£ğ˜´ğ˜¤ğ˜³ğ˜ªğ˜±ğ˜µğ˜ªğ˜°ğ˜¯.request(long n)
            ---------------------------------------->
Subscriber                  â—€â”€â”€â”€â”€â–¶                      Publisher
            <----------------------------------------
                    Subscriber.next(T) .. n-Times


ğŸ›‘   End of Association

                    Subscriber.onError(Throwable)
Subscriber  <----------------------------------------   Publisher

                    Subscriber.onComplete()
Subscriber  <----------------------------------------   Publisher

                    ğ˜šğ˜¶ğ˜£ğ˜´ğ˜¤ğ˜³ğ˜ªğ˜±ğ˜µğ˜ªğ˜°ğ˜¯.cancel()
Subscriber  ---------------------------------------->   Publisher


ğšƒğšğš›ğš–ğš’ğš—ğš˜ğš•ğš˜ğšğš’ğšğšœ
â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾
â€¢ Publisher
    Source  | Ovservable | Upstream   | Producer
â€¢ Subscriber
    Sink    | Observer   | Downstream | Consumer
â€¢ Processor
    Operator


ğšğšğš•ğšğšœ ğš˜ğš ğšğšğšŠğšŒğšğš’ğšŸğš ğ™¿ğš›ğš˜ğšğš›ğšŠğš–ğš–ğš’ğš—ğš
â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾

â€¢   Subscriber has to subscribe and request for the producer to produce items.
    The idea is to be lazy
â€¢   Subscriber can cancel anytime.
â€¢   If there are no Subscribers left, then the Producer will not produce 
	anything
â€¢   Producer will produce items via. onNext
â€¢   Producer will call onComplete after emitting 0...N data.

    According to the ğ—¥ğ—²ğ—®ğ—°ğ˜ğ—¶ğ˜ƒğ—² ğ—¦ğ˜ğ—¿ğ—²ğ—®ğ—ºğ˜€ ğ—¦ğ—½ğ—²ğ—°ğ—¶ğ—³ğ—¶ğ—°ğ—®ğ˜ğ—¶ğ—¼ğ—», a ğ™¿ğšğš‹ğš•ğš’ğšœğš‘ğšğš› stream must
    call the ğš˜ğš—ğ™²ğš˜ğš–ğš™ğš•ğšğšğš() signal to its ğš‚ğšğš‹ğšœğšŒğš›ğš’ğš‹ğšğš› when it has successfully
    transmitted all the data and there are no more elements to emit.

    This signals the end of the stream and indicates that the Subscriber will
    not receive any further ğš˜ğš—ğ™½ğšğš¡ğš() calls from this Publisher.

    In Reactor, both ğ™µğš•ğšğš¡ (for streams of 0 .. N elements) and ğ™¼ğš˜ğš—ğš˜ (for
    streams of 0 or 1 element) will emit an ğš˜ğš—ğ™²ğš˜ğš–ğš™ğš•ğšğšğš() signal under normal
    completion scenarios after all data has been emitted.

â€¢ Producer will call onError when something breaks
â€¢ Producer will not invoke anything after onComplete/onError


  ____                 _
 |  _ \ ___  __ _  ___| |_ ___  _ __
 | |_) / _ \/ _` |/ __| __/ _ \| '__|
 |  _ <  __/ (_| | (__| || (_) | |
 |_| \_\___|\__,_|\___|\__\___/|_|


    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   public interface Publisher<T> {                     â”‚
    â”‚       public void subscribe(Subscriber <? super T> s);â”‚ ğ—£ğ˜‚ğ—¯ğ—¹ğ—¶ğ˜€ğ—µğ—²ğ—¿
    â”‚   }                                                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                â”‚                           â”‚
                â”‚                           â”‚
                â”‚                           â”‚
                Ë…                           Ë…
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            â”‚  Mono<T>  â”‚               â”‚  Flux<T>  â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯               â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
            â€¢ O or 1 item               â€¢ 0 .. N items
            â€¢ onComplete / onError      â€¢ onComplete / onError
            â€¢ No Stream                 â€¢ Stream of messages
            â€¢ No Back-Pressure          â€¢ Back-Pressure (produce more than
            â€¢ Light-Weight Publisher      what can be consumed)
            â€¢ Request-Response model    â€¢ Many additional methods related to
                                          stream processing


    Both Mono and Flux can handle records in a Non-Blocking and Asynchronous
    manner

    ğ—¥ğ—²ğ—®ğ—°ğ˜ğ—¶ğ˜ƒğ—² ğ—¦ğ˜ğ—¿ğ—²ğ—®ğ—ºğ˜€ ğ—®ğ—¿ğ—² ğ—¶ğ—»ğ—µğ—²ğ—¿ğ—²ğ—»ğ˜ğ—¹ğ˜† ğ—Ÿğ—®ğ˜‡ğ˜†. Â 

    Operations within a Reactive Streams Pipeline are not executed until a
    Subscriber actively subscribes to the Publisher and starts requesting data.
    The following reasons explain the behavior -

    ğ—¡ğ—¼ ğ—¦ğ˜‚ğ—¯ğ˜€ğ—°ğ—¿ğ—¶ğ—½ğ˜ğ—¶ğ—¼ğ—», ğ—¡ğ—¼ ğ—ªğ—¼ğ—¿ğ—¸: Until a Subscriber calls the subscribe() method on
    a Publisher, the Publisher does not start producing or processing any data.

    ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ ğ—™ğ˜‚ğ˜€ğ—¶ğ—¼ğ—»: Reactive Streams implementations (like Reactor and RxJava)
    often employ operator fusion techniques. This can optimize the execution by
    combining multiple operators into a single step, which only happens when the
    stream is actually consumed. Â 

    ğ——ğ—²ğ—ºğ—®ğ—»ğ—±-ğ——ğ—¿ğ—¶ğ˜ƒğ—²ğ—»: The Subscriber controls the rate at which it receives data
    by making explicit requests (using the request(n) method). The Publisher
    only produces and pushes data in response to this demand. This pull-based
    backpressure mechanism further reinforces the lazy nature.

    Reactive Streams set up a blueprint for data processing, but the actual
    processing is deferred until there's a consumer actively pulling the data
    through the pipeline. This lazy evaluation is crucial for efficiency,
    especially when dealing with potentially large or infinite streams of data.

    â•”â•â•â•â•â•â•â•â•—
    â•‘  Mono â•‘
    â•šâ•â•â•â•â•â•â•â•

    ğ— ğ—¼ğ—»ğ—¼<ğ—§> ğ—·ğ˜‚ğ˜€ğ˜(ğ—§ ğ—±ğ—®ğ˜ğ—®)

    â—‹   A common use case of this method would be to create a Mono type
    Publisher to match the parameter(s) of a method which requires a Publisher,
    in place of the "data".
    â—‹   Use 'just' when the values we need to send, need to be in the memory

    ğ— ğ—¼ğ—»ğ—¼.ğ˜€ğ˜‚ğ—¯ğ˜€ğ—°ğ—¿ğ—¶ğ—¯ğ—²(ğ—™ğ˜‚ğ—»ğ—°ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—œğ—»ğ˜ğ—²ğ—¿ğ—³ğ—®ğ—°ğ—²(ğ˜€))

    â—‹   The request method to the Subscription is automatically created by the
    Reactor runtime based on the method call.

    ğ— ğ—¼ğ—»ğ—¼.ğ—³ğ—¿ğ—¼ğ—ºğ—¦ğ˜‚ğ—½ğ—½ğ—¹ğ—¶ğ—²ğ—¿(ğ—¦ğ˜‚ğ—½ğ—½ğ—¹ğ—¶ğ—²ğ—¿<? ğ—²ğ˜…ğ˜ğ—²ğ—»ğ—±ğ˜€ ğ—§> ğ˜€ğ˜‚ğ—½ğ—½ğ—¹ğ—¶ğ—²ğ—¿)

    â—‹   Delay compute intensive operation
    â—‹   Supports any supplier

    ğ— ğ—¼ğ—»ğ—¼.ğ—³ğ—¿ğ—¼ğ—ºğ—–ğ—®ğ—¹ğ—¹ğ—®ğ—¯ğ—¹ğ—²(ğ—–ğ—®ğ—¹ğ—¹ğ—®ğ—¯ğ—¹ğ—²<? ğ—²ğ˜…ğ˜ğ—²ğ—»ğ—±ğ˜€ ğ—§> ğ˜€ğ˜‚ğ—½ğ—½ğ—¹ğ—¶ğ—²ğ—¿)

    â—‹   The callable interface is a very old interface and has existed
    â—‹   JavaDocs

        A task that returns a result and may throw an exception. Implementors
        define a single method with no arguments called call.

        The Callable interface is similar to Runnable, in that both are designed
        for classes whose instances are potentially executed by another thread.

        A Runnable, however, does not return a result and cannot throw a checked
        exception.

        Callable throws Exception whereas Supplier throws RuntimeException

    â—‹   Callable has a throws clause | Supplier doesn't

    ğ— ğ—¼ğ—»ğ—¼.ğ—³ğ—¿ğ—¼ğ—ºğ—¥ğ˜‚ğ—»ğ—»ğ—®ğ—¯ğ—¹ğ—²(ğ—¥ğ˜‚ğ—»ğ—»ğ—®ğ—¯ğ—¹ğ—² ğ—¿ğ˜‚ğ—»ğ—»ğ—®ğ—¯ğ—¹ğ—²)

    â—‹   Perform a task and return an Mono.Empty after the Runnable, that is
        passed as a parameter has been executed

    ğ— ğ—¼ğ—»ğ—¼.ğ—³ğ—¿ğ—¼ğ—ºğ—™ğ˜‚ğ˜ğ˜‚ğ—¿ğ—²(ğ—–ğ—¼ğ—ºğ—½ğ—¹ğ—²ğ˜ğ—®ğ—¯ğ—¹ğ—²ğ—™ğ˜‚ğ˜ğ˜‚ğ—¿ğ—²<? ğ—²ğ˜…ğ˜ğ—²ğ—»ğ—±ğ˜€ ğ—§> ğ—³ğ˜‚ğ˜ğ˜‚ğ—¿ğ—²)

    â—‹   Integrate existing asynchronous operations that are based on
        CompletableFuture into a Reactor-based reactive pipeline.

    â—‹   If the CompletableFuture completes successfully with a value, the Mono
        will emit that value as an onNext() signal followed by an onComplete()
        signal.

    â—‹   If the CompletableFuture completes without a value (i.e., a
        CompletableFuture<Void>), the Mono will simply emit an onComplete()
        signal.

    â—   CompletableFuture is not lazy. If Mono.fromFuture is associated with a
        CompletableFuture and there is no association with a subscriber, then
        that is not a Lazy computation because the computation of the
        CompletableFuture code will start immediately.

        Mono
            .fromFuture(getName());

        private static CompletableFuture<String> getName() {
            return CompletableFuture.supplyAsync(() -> {
                logger.info("Get Name from CompletableFuture");
                return Util.faker().name().firstName();
            });
        }

    â—‹   CompletableFuture can be made to execute with a delay by using it in the
        form of a Supplier

        Mono
            .fromFuture(()-> getName());

    ğ— ğ—¼ğ—»ğ—¼.ğ—±ğ—²ğ—³ğ—²ğ—¿(ğ—¦ğ˜‚ğ—½ğ—½ğ—¹ğ—¶ğ—²ğ—¿<? ğ—²ğ˜…ğ˜ğ—²ğ—»ğ—±ğ˜€ ğ— ğ—¼ğ—»ğ—¼<? ğ—²ğ˜…ğ˜ğ—²ğ—»ğ—±ğ˜€ ğ—§>> ğ˜€ğ˜‚ğ—½ğ—½ğ—¹ğ—¶ğ—²ğ—¿)

    â—‹   Defer the invocation of the Publisher


    ğ—Ÿğ—¼ğ—¼ğ—½ğ—¥ğ—²ğ˜€ğ—¼ğ˜‚ğ—¿ğ—°ğ—²ğ˜€

    ğš›ğšğšŠğšŒğšğš˜ğš›.ğš—ğšğšğšğš¢.ğš›ğšğšœğš˜ğšğš›ğšŒğšğšœ.ğ™»ğš˜ğš˜ğš™ğšğšğšœğš˜ğšğš›ğšŒğšğšœ

    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
    â”‚ Non Blocking IO (Simplified)  â”‚
    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

    ğ—œğ—»ğ—¯ğ—¼ğ˜‚ğ—»ğ—±
                [6]     [5]     [4]                 â•­>â•®         [3]
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>         â†‘ â”‚     -------------->
    <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”‚ â†“     <--------------
                                                    â•°<â•¯         [1]
                ğ—¢ğ˜‚ğ˜ğ—¯ğ—¼ğ˜‚ğ—»ğ—±                        ğ—˜ğ˜ƒğ—²ğ—»ğ˜ ğ—Ÿğ—¼ğ—¼ğ—½
                                                   ğ˜›ğ˜©ğ˜³ğ˜¦ğ˜¢ğ˜¥
    â€¢ Send the first Request | Don't sit idle
    â€¢ Pick the next Request

    â•”â•â•â•â•â•â•â•â•—
    â•‘ Flux  â•‘
    â•šâ•â•â•â•â•â•â•â•

	â—‹	ğ—Ÿğ—¼ğ—´ ğ—¨ğ—»ğ—¯ğ—¼ğ˜‚ğ—»ğ—±ğ—²ğ—±: 
		Requesting for Integer.MAX_VALUE number of items cause the Log() method 
		of Flux to print 'unbounded'
	â—‹	The log method can only print what is happening between its producer and
		its subscriber
	â—‹	ğ—™ğ—¹ğ˜‚ğ˜… ğ—³ğ—¿ğ—¼ğ—º ğ—¦ğ˜ğ—¿ğ—²ğ—®ğ—ºğ˜€:
		When creating a Flux from Streams, we need to be aware that Streams are
		invalidated when they end
	â—‹	ğ—™ğ—¹ğ˜‚ğ˜… ğ—œğ—»ğ˜ğ—²ğ—¿ğ˜ƒğ—®ğ—¹:
		This carries on until explicitly told to stop
	â—‹	ğ—™ğ—¹ğ˜‚ğ˜….ğ—±ğ—²ğ—³ğ—²ğ—¿:
		Delay Execution. Operates similar to Supplier, Callable & Runnable.
	â—‹	Mono <â€”> Flux

	ğ—™ğ—¹ğ˜‚ğ˜… - ğ—˜ğ—ºğ—¶ğ˜ğ˜ğ—¶ğ—»ğ—´ ğ—œğ˜ğ—²ğ—ºğ˜€ ğ—£ğ—¿ğ—¼ğ—´ğ—¿ğ—®ğ—ºğ—ºğ—®ğ˜ğ—¶ğ—°ğ—®ğ—¹ğ—¹ğ˜†

	This topic is about creating flux from things which are not already in the 
	memory, etc.
	
	â—‹	Flux.create(Consumer<? super FluxSink<T>>)
	
		â†’ Can generate items as we wish
		â†’ e.g. Loop, Timer, Loop with condition, etc.

	â—‹	ğŸ’¡FluxSink is Thread Safe
	
	â—‹	FluxSink does not wait for subscribers to subscribe and request for data
		Operations, like loops,  inside a FluxSink are executed up front.
		This enables creating the values to be generated and stored to meet 
		future demands.
	
	â—‹	The Flux Queue is an unbounded queue
	
	â—‹	ğŸ§  Maximum number of items that can be stored (for future emission) 
		in the Flux Queue is Integer.MAX_VALUE
		
	â—‹	Back-Pressure: More items in Flux Queue than what is consumed

	ğ—™ğ—¹ğ˜‚ğ˜… - ğ—˜ğ—ºğ—¶ğ˜ ğ—¼ğ—» ğ——ğ—²ğ—ºğ—®ğ—»ğ—±
	
	â—‹	<fluxSink>.onRequest(LongConsumer) - the long value initiates the 
		production
	â—‹	<fluxSink>.isCancelled - whether the fluxSink was cancelled

	â—‹	Points to remember about Flux.create and Flux.Sink
		- Designed for a ğ™¨ğ™ğ™£ğ™œğ™¡ğ™š subscriber
		- Thread Safe
		- Allows perpetual (metaphorically speaking) production of data, without
		  worrying about downstream demand
		- Delivers data sequentially & safely
		- Stores pre-generated data in a Queue

	ğ—§ğ—®ğ—¸ğ—² ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿
	
	â—‹	take(long n) - take only the first n values from this stream, if 
		available
		Similar to the "limit" operator of java.util.Streams
	â—‹	takeWhile - as long as the condition is true
	â—‹	takeUntil - until the given condition occurs
	
	ğ—™ğ—¹ğ˜‚ğ˜… - ğ—šğ—²ğ—»ğ—²ğ—¿ğ—®ğ˜ğ—²
	
	â—‹	Uses a SynchronousSink
	â—‹	Can only take one .next() method call per Flux.generate
	â—‹	Genarates data based on the downstream demand
	â—‹	Absence of a limiting method call would cause the generate method to run 
		for ever
	â—‹	Examples of terminal operations
		- take
		- SynchronousSink.complete
		- SynchronousSink.error
	
	
	ğ—™ğ—¹ğ˜‚ğ˜… ğ—šğ—²ğ—»ğ—²ğ—¿ğ—®ğ˜ğ—² - ğ—£ğ—¿ğ—¼ğ—¯ğ—¹ğ—²ğ—º ğ˜„ğ—¶ğ˜ğ—µ ğ—¦ğ˜ğ—®ğ˜ğ—²
	
	â—‹	Flux.generate calls the generator function iteratively to generate 	
		values. This prevents us from declaring any counter inside the 
		generator block because the value would be reset in the next iteration.
	
	â—‹	Use the overloaded generate method
	
		<T, S> Flux<T> generate(
			Callable<S> stateSupplier, 
			BiFunction<S, SynchronousSink<T>, S> generator, 
			Consumer<? super S> stateConsumer
		)
		
		The first parameter supplies the initial state value
		
	â—‹	Create								  	Generate
		â€¢ 	Accepts a 						| 	â€¢	Accepts a 
			Consumer<FluxSink<T>>			|		Consumer<Synchronous<T>>
		â€¢	Consumer is invoked only once	|	â€¢	Consumer is invoked
											|		multiple times
		â€¢	Consumer can emit any number of	|	â€¢	Consumer can emit only one 
			elements, irrespective of 		|		element; downstream demand
			downstream demand				|		governs emission
		â€¢	Thread Safe						|	â€¢	N/A - because we can emit 
											|		only one item at a time
	
	
	â•”â•â•â•â•â•â•â•â•â•â•â•â•—
	â•‘ Operators â•‘ [TODO: Not thorough/exhaustive]
	â•šâ•â•â•â•â•â•â•â•â•â•â•â•
	
	â—‹ 	Additional behaviors by the use of Operators require new subscriptions
	
		 â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
	     â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
		 â”‚ â”‚  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  â”‚ â”‚
		 â”‚ â”‚  â”‚	â•­â”€â”€â”€â”€â”€â”€â•® â”‚  â”‚ â”‚
		 â”‚ â”‚  â”‚	â”‚      â”‚ â”‚  â”‚ â”‚
		 â”‚ â”‚  â”‚	â•°â”€â”€â”€â”€â”€â”€â•¯ â”‚  â”‚ â”‚
		 â”‚ â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  â”‚ â”‚
		 â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
		 â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

	â—‹	Important methods

		ğšğš˜ğ™°ğšğšğšğš›ğšƒğšğš›ğš–ğš’ğš—ğšŠğšğš 	- Post Flux termination | completion or error
		ğšğš˜ğ™µğš’ğš—ğšŠğš•ğš•ğš¢			- Post Flux termination | any reason, including cancellation
		ğšğš˜ğ™µğš’ğš›ğšœğš				- Before subscription 
		ğšğš˜ğ™¾ğš—ğ™²ğšŠğš—ğšŒğšğš•			- Flux cancellation
		ğšğš˜ğ™¾ğš—ğ™²ğš˜ğš–ğš™ğš•ğšğšğš		- Flux completion
		ğšğš˜ğ™¾ğš—ğ™³ğš’ğšœğšŒğšŠğš›ğš		- Potentially modify the behavior of the whole chain 
							  of operators upstream of this one to conditionally 
							  clean up elements that get discarded by these 
							  operators.
		ğšğš˜ğ™¾ğš—ğ™´ğšŠğšŒğš‘			- Item emission | Completion | Error

		ğšğš˜ğ™¾ğš—ğ™´ğš›ğš›ğš˜ğš›(ğ™²ğš˜ğš—ğšœğšğš–ğšğš›<? ğšœğšğš™ğšğš› ğšƒğš‘ğš›ğš˜ğš ğšŠğš‹ğš•ğš> ğš˜ğš—ğ™´ğš›ğš›ğš˜ğš›) - On an Error
		ğšğš˜ğ™¾ğš—ğ™´ğš›ğš›ğš˜ğš›(ğ™²ğš•ğšŠğšœğšœ<ğ™´> ğšğš¡ğšŒğšğš™ğšğš’ğš˜ğš—ğšƒğš¢ğš™ğš, ğ™²ğš˜ğš—ğšœğšğš–ğšğš›<? ğšœğšğš™ğšğš› ğ™´> ğš˜ğš—ğ™´ğš›ğš›ğš˜ğš›) 
							- On an Error matching the given Exception Type
		ğšğš˜ğ™¾ğš—ğ™´ğš›ğš›ğš˜ğš›(ğ™¿ğš›ğšğšğš’ğšŒğšŠğšğš<? ğšœğšğš™ğšğš› ğšƒğš‘ğš›ğš˜ğš ğšŠğš‹ğš•ğš> ğš™ğš›ğšğšğš’ğšŒğšŠğšğš, ğ™²ğš˜ğš—ğšœğšğš–ğšğš›<? ğšœğšğš™ğšğš› 
		ğšƒğš‘ğš›ğš˜ğš ğšŠğš‹ğš•ğš> ğš˜ğš—ğ™´ğš›ğš›ğš˜ğš›)  
							- On error and given condintion
		ğšğš˜ğ™¾ğš—ğ™½ğšğš¡ğš			- Emission
		ğšğš˜ğ™¾ğš—ğšğšğššğšğšğšœğš		- Longconsumer request
		ğšğš˜ğ™¾ğš—ğš‚ğšğš‹ğšœğšŒğš›ğš’ğš‹ğš		- On subscription: when a subscription is produced 
							  by the publisher and is being passed to the 
							  ğš‚ğšğš‹ğšœğšŒğš›ğš’ğš‹ğšğš›.ğš˜ğš—ğš‚ğšğš‹ğšœğšŒğš›ğš’ğš‹ğš(ğš‚ğšğš‹ğšœğšŒğš›ğš’ğš™ğšğš’ğš˜ğš—) method
		ğšğš˜ğ™¾ğš—ğšƒğšğš›ğš–ğš’ğš—ğšŠğšğš		- On termination
		
		Direction of Call Flow
		â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œ
		â€¢ Subscription calls move from the Subscriber to the Producer
		â€¢ Completion and Error messages move from the Producer to the Subscriber
		â€¢ doFinally moves from the Subscriber to the Producer
		â€¢ Calls other than doXXX calls which come in the path of the calls 
		  are taken into account and affect the subsequent calls
		â€¢ Take calls for a cancel and it navigates upstream - to the Producer
		â€¢ Take calls onComplete downstream
		â€¢ Scenario: Producer.take(20).take(4).subscribe(...) will produce an 
		  onRequest log of 4 for take(20) instead of 20 because the lower take
		  call has a value of 4.
	
	â—‹	Operator - Delay Elements
	
		â€¢ Delay the execution of emitting items
		â€¢ When we use a delay, the items are emitted in a delayed manner
	
	â—‹	Subscribe Method + Callback Methods
	
		- We can use subscribe method with preceding callbacks to create similar
		  effect as that of implementing our own Subscriber
		  
		Example:
		
		Flux.range(1, 10)
            .doOnNext(integer -> 
				logger.info("Called doOnNext with value {}", integer)
			)
            .doOnComplete(() -> logger.info("doOnComplete-1"))
            .doOnError(err -> logger.error("Error: ", err))
            .subscribe(System.out::println);
	
	â—‹	Error Handling - Flux and Mono
	
		ğŸ‘‰ All flavors of should be placed after the error producing method
	
		.ğš˜ğš—ğ™´ğš›ğš›ğš˜ğš›ğšğšğšğšğš›ğš— - Fallback value when there is an error
		.ğš˜ğš—ğ™´ğš›ğš›ğš˜ğš›ğšğšğšğšğš›ğš—(ğ™²ğš•ğšŠğšœğšœ<ğ™´> ğšğš¢ğš™ğš, ğšƒ ğšğšŠğš•ğš•ğš‹ğšŠğšŒğš”ğš…ğšŠğš•ğšğš)
						 - Fallback value when there is an error of the given 
						 type
		.ğš˜ğš—ğ™´ğš›ğš›ğš˜ğš›ğšğšğšğšğš›ğš—(
			ğ™¿ğš›ğšğšğš’ğšŒğšŠğšğš<? ğšœğšğš™ğšğš› ğšƒğš‘ğš›ğš˜ğš ğšŠğš‹ğš•ğš> ğš™ğš›ğšğšğš’ğšŒğšŠğšğš, ğšƒ ğšğšŠğš•ğš•ğš‹ğšŠğšŒğš”ğš…ğšŠğš•ğšğš
		)
						 - Fallback value when there is an error which matches
						 the condition
		
		
		â“VALIDATE .onErrorXXX methods go to the next error handling option in 
		case the current and previous ones are not able to match the error 
		handling condition.
		The next available error option(s) are also considered if a fallback 
		error handling method itself throws an error
		
		ğš˜ğš—ğ™´ğš›ğš›ğš˜ğš›ğ™²ğš˜ğš–ğš™ğš•ğšğšğš: Hide current error and go to .onComplete
	
	
	â—‹	Multiple Timeout Options
	
		Rule: The least .timeout() value that is closest to the producer 
		effectively determines the timeout value
	
	â—‹	Transform Options
	
		If there are multiple workflows with redundant subsequent steps, then 
		these common steps can be resued by placing them in a common method.
		
		UnaryOperator<Flux<T>> commonSteps() {
			return flux -> flux
				.doThis(...)
				.doThat(...)
				.doSomethingElse(...)
		}
	
		Related Topic: 
			Function.identity() - 	return the value as is; do not perform any
									changes
	
	â—‹	

	â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
	â•‘ Hot/Cold Subscribers â•‘
	â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	2 types of Publishers - Hot & Cold
	
	Cold
	â€¾â€¾â€¾â€¾
	â—‹	Publisher emits data only when a Subscriber subscribes to it
	â—‹	A Publisher provides completely ğ’Šğ’ğ’…ğ’†ğ’‘ğ’†ğ’ğ’…ğ’†ğ’ğ’• data streams for each of 
		its Subscriber(s) â”€> No Conflicts

	Hot
	â€¾â€¾â€¾
	â—‹	Publisher emits data independent of subscriptions
	â—‹	Data is shared among the subscribers

	Default behavior of a FluxSink
	â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾
	A FluxSink instance can be only shared with one subscriber at a time.
	A FluxSink needs to attach itself to a Flux and this step is executed every 
	time a new subscriber attaches subscribes to a involves the 
	creation 
	
	FluxSink with Multiple Subscribers
	â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾
	If we want to have multiple subscribers to a FluxSink then we just need to
	use call share() method on the 

	â—‹	ğ™µğš•ğšğš¡.ğšœğš‘ğšŠğš›ğš() is the same as ğ™µğš•ğšğš¡.ğš™ğšğš‹ğš•ğš’ğšœğš‘().ğš›ğšğšğ™²ğš˜ğšğš—ğš(ğŸ·)
		The ğš›ğšğšğ™²ğš˜ğšğš—ğš(ğš’ğš—ğš ğš–ğš’ğš—ğš‚ğšğš‹ğšœğšŒğš›ğš’ğš‹ğšğš›ğšœ) method sets the minimum number of
		active subscribers required (to be subscribed) in order for the 
		Publisher to emit items
		
	â—‹	A Flux needs ğ—®ğ˜ ğ—¹ğ—²ğ—®ğ˜€ğ˜ ğ—¼ğ—»ğ—² ğ˜€ğ˜‚ğ—¯ğ˜€ğ—°ğ—¿ğ—¶ğ—¯ğ—²ğ—¿ for the Producer to emit data.
	
	Resubscription
	â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾
	â—‹	Process of subscribing to a Publisher from which all previous 
		subscribers had unsubscribled
	â—‹	Causes the Publisher to start streaming from the beginning

	
	ğ™µğš•ğšğš¡.ğš™ğšğš‹ğš•ğš’ğšœğš‘().ğšŠğšğšğš˜ğ™²ğš˜ğš—ğš—ğšğšŒğš() - doesn't wait for subscribers, keeps 
	streaming
	
	Hot Publisher - Replay / Cache
	â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾
	use replay in place of publish